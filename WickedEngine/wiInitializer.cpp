#include "wiInitializer.h"
#include "WickedEngine.h"

#include <thread>
#include <atomic>

#if defined(PLATFORM_WINDOWS_DESKTOP) || defined(PLATFORM_LINUX)
#include "Utility/cpuinfo.hpp"
#endif // defined(PLATFORM_WINDOWS_DESKTOP) || defined(PLATFORM_LINUX)

namespace wi::initializer
{
	static std::atomic_bool initializationStarted{ false };      // atomic flag indicating if async initialization for the application components\systems is started
	static wi::jobsystem::context ctx;                           // job system context for async initialization
	static wi::Timer timer;								         // timer to measure initialization time
	static std::atomic_bool systems[INITIALIZED_SYSTEM_COUNT]{}; // atomic flags to check if a specific component\system (or all of them) has been initialized already

	void InitializeComponentsImmediate()
	{
		if (IsInitializeFinished())
			return;
		if (!initializationStarted.load())
		{
			InitializeComponentsAsync();
		}
		WaitForInitializationsToFinish();
	}
	void InitializeComponentsAsync()
	{
		if (IsInitializeFinished())
			return;
		timer.record();

		initializationStarted.store(true);

#if defined(PLATFORM_WINDOWS_DESKTOP)
		static constexpr const char* platform_string = "Windows";
#elif defined(PLATFORM_LINUX)
		static constexpr const char* platform_string = "Linux";
#elif defined(PLATFORM_PS5)
		static constexpr const char* platform_string = "PS5";
#elif defined(PLATFORM_XBOX)
		static constexpr const char* platform_string = "Xbox";
#endif // PLATFORM

		wilog("\n[wi::initializer] Initializing Wicked Engine, please wait...\nVersion: %s\nPlatform: %s", wi::version::GetVersionString(), platform_string);

		StackString<1024> cpustring;
#if defined(PLATFORM_WINDOWS_DESKTOP) || defined(PLATFORM_LINUX)
		CPUInfo cpuinfo;
		cpustring.push_back("\nCPU: ");
		cpustring.push_back(cpuinfo.model().c_str());
		cpustring.push_back("\n\tFeatures available: ");
		if (cpuinfo.haveSSE())
		{
			cpustring.push_back("SSE; ");
		}
		if (cpuinfo.haveSSE2())
		{
			cpustring.push_back("SSE 2; ");
		}
		if (cpuinfo.haveSSE3())
		{
			cpustring.push_back("SSE 3; ");
		}
		if (cpuinfo.haveSSE41())
		{
			cpustring.push_back("SSE 4.1; ");
		}
		if (cpuinfo.haveSSE42())
		{
			cpustring.push_back("SSE 4.2; ");
		}
		if (cpuinfo.haveAVX())
		{
			cpustring.push_back("AVX; ");
		}
		if (cpuinfo.haveFMA3())
		{
			cpustring.push_back("FMA3; ");
		}
		if (cpuinfo.haveF16C())
		{
			cpustring.push_back("F16C; ");
		}
		if (cpuinfo.haveAVX2())
		{
			cpustring.push_back("AVX 2; ");
		}
		if (cpuinfo.haveAVX512F())
		{
			cpustring.push_back("AVX 512; ");
		}
#endif // defined(PLATFORM_WINDOWS_DESKTOP) || defined(PLATFORM_LINUX)
		cpustring.push_back("\n\tFeatures used: ");
#ifdef _XM_SSE_INTRINSICS_
		cpustring.push_back("SSE; ");
		cpustring.push_back("SSE 2; ");
#endif // _XM_SSE_INTRINSICS_
#ifdef _XM_SSE3_INTRINSICS_
		cpustring.push_back("SSE 3; ");
#endif // _XM_SSE3_INTRINSICS_
#ifdef _XM_SSE4_INTRINSICS_
		cpustring.push_back("SSE 4.1; ");
#endif // _XM_SSE4_INTRINSICS_
#ifdef _XM_AVX_INTRINSICS_
		cpustring.push_back("AVX; ");
#endif // _XM_AVX_INTRINSICS_
#ifdef _XM_FMA3_INTRINSICS_
		cpustring.push_back("FMA3; ");
#endif // _XM_FMA3_INTRINSICS_
#ifdef _XM_F16C_INTRINSICS_
		cpustring.push_back("F16C; ");
#endif // _XM_F16C_INTRINSICS_
#ifdef _XM_AVX2_INTRINSICS_
		cpustring.push_back("AVX 2; ");
#endif // _XM_AVX2_INTRINSICS_
#ifdef _XM_ARM_NEON_INTRINSICS_
		cpustring.push_back("NEON; ");
#endif // _XM_ARM_NEON_INTRINSICS_

		wi::backlog::post(cpustring.c_str());

		if (!XMVerifyCPUSupport())
		{
			wilog_messagebox("XMVerifyCPUSupport() failed! This means that your CPU doesn't support a required feature! %s", cpustring.c_str());
		}

		wilog("\nRAM: %s", wi::helper::GetMemorySizeText(wi::helper::GetMemoryUsage().total_physical).c_str());

		// Returns how many shaders are embedded (if wiShaderDump.h is used).
		// wiShaderDump.h contains precompiled shader binary data and can be generated by OfflineShaderCompiler.exe using the shaderdump argument.
		size_t shaderdump_count = wi::renderer::GetShaderDumpCount();
		if (shaderdump_count > 0)
		{
			wilog("\nEmbedded shaders found: %d", (int)shaderdump_count);
		}
		else
		{
			wilog("\nNo embedded shaders found, shaders will be compiled at runtime if needed.\n\tShader source path: %s\n\tShader binary path: %s", wi::renderer::GetShaderSourcePath().c_str(), wi::renderer::GetShaderPath().c_str());
		}

		wi::backlog::post("");

		// Start some threads that execute jobs (in parallel, if actually available) stored in job queues (otherwise, they simply waits)
		wi::jobsystem::Initialize();

		wi::backlog::post("");

		// Each wi::jobsystem::Execute add a job to the a job queue and wake up a sleeping thread to initialize a system.
		// Each call to wi::jobsystem::Execute executes in parallel if there are available threads.
		// A Job is a structure that contains a context, a task, etc.
		// A task is a function that takes a JobArgs structure as an argument.
		// A context defines the state of execution (priority of execution and number of threads that are executing a job in parallel at the same priority level).
		wi::jobsystem::Execute(ctx, [](wi::jobsystem::JobArgs args) { wi::image::Initialize(); systems[INITIALIZED_SYSTEM_IMAGE].store(true); });
		wi::jobsystem::Execute(ctx, [](wi::jobsystem::JobArgs args) { wi::input::Initialize(); systems[INITIALIZED_SYSTEM_INPUT].store(true); });
		wi::jobsystem::Execute(ctx, [](wi::jobsystem::JobArgs args) { wi::renderer::Initialize(); systems[INITIALIZED_SYSTEM_RENDERER].store(true); });
		wi::jobsystem::Execute(ctx, [](wi::jobsystem::JobArgs args) { wi::texturehelper::Initialize(); systems[INITIALIZED_SYSTEM_TEXTUREHELPER].store(true); });
		wi::jobsystem::Execute(ctx, [](wi::jobsystem::JobArgs args) { wi::HairParticleSystem::Initialize(); systems[INITIALIZED_SYSTEM_HAIRPARTICLESYSTEM].store(true); });
		wi::jobsystem::Execute(ctx, [](wi::jobsystem::JobArgs args) { wi::EmittedParticleSystem::Initialize(); systems[INITIALIZED_SYSTEM_EMITTEDPARTICLESYSTEM].store(true); });
		wi::jobsystem::Execute(ctx, [](wi::jobsystem::JobArgs args) { wi::Ocean::Initialize(); systems[INITIALIZED_SYSTEM_OCEAN].store(true); });
		wi::jobsystem::Execute(ctx, [](wi::jobsystem::JobArgs args) { wi::gpusortlib::Initialize(); systems[INITIALIZED_SYSTEM_GPUSORTLIB].store(true); });
		wi::jobsystem::Execute(ctx, [](wi::jobsystem::JobArgs args) { wi::GPUBVH::Initialize(); systems[INITIALIZED_SYSTEM_GPUBVH].store(true); });
		wi::jobsystem::Execute(ctx, [](wi::jobsystem::JobArgs args) { wi::physics::Initialize(); systems[INITIALIZED_SYSTEM_PHYSICS].store(true); });
		wi::jobsystem::Execute(ctx, [](wi::jobsystem::JobArgs args) { wi::TrailRenderer::Initialize(); systems[INITIALIZED_SYSTEM_TRAILRENDERER].store(true); });

		// Initialize these immediately:
		wi::lua::Initialize(); systems[INITIALIZED_SYSTEM_LUA].store(true);
		wi::audio::Initialize(); systems[INITIALIZED_SYSTEM_AUDIO].store(true);
		wi::font::Initialize(); systems[INITIALIZED_SYSTEM_FONT].store(true);

		// Start a thread that waits for the job system to finish all jobs queued above
		std::thread([] {
			wi::jobsystem::Wait(ctx);
			wilog("\n[wi::initializer] Wicked Engine Initialized (%d ms)", (int)std::round(timer.elapsed()));
		}).detach();

	}

	// Check if one or all systems are initialized by verifying an atomic flag and if the job system is busy
	bool IsInitializeFinished(INITIALIZED_SYSTEM system)
	{
		if (system == INITIALIZED_SYSTEM_COUNT)
		{
			return initializationStarted.load() && !wi::jobsystem::IsBusy(ctx);
		}
		else
		{
			return systems[system].load();
		}
	}

	void WaitForInitializationsToFinish()
	{
		wi::jobsystem::Wait(ctx);
	}
}
